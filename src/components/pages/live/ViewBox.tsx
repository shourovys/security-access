import React, { useEffect, useRef, useState } from 'react'
import useSWRMutation from 'swr/mutation'
import { sendPostRequest } from '../../../api/swrConfig'
import { cameraApi, channelApi } from '../../../api/urls'
import FormCardWithHeader from '../../../components/HOC/FormCardWithHeader'
import FormContainer from '../../../components/HOC/style/form/FormContainer'
import LiveBox from '../../../components/pages/live/LiveBox'
import { IActionsButton } from '../../../types/components/actionButtons'
import { IStreamResult } from '../../../types/pages/camera'
import { ISingleServerResponse } from '../../../types/pages/common'
import { STREAM_URL } from '../../../utils/config'
import { channelIcon } from '../../../utils/icons'
import t from '../../../utils/translator'

// Interface for the props passed to the component
interface IProps {
  type: 'camera' | 'channel'
  name?: string | null
  deviceId?: string | null
  isLoading?: boolean
}

const ViewBox: React.FC<IProps> = ({ type, name, deviceId, isLoading }) => {
  // State to manage the current streaming type ('main' or 'sub')
  const [currentStreamingType, setCurrentStreamingType] = useState<'main' | 'sub'>('main')

  // State to store streaming data received from the server
  const [streamingData, setStreamingData] = useState<IStreamResult>({
    StreamingUrl: '',
    StreamingId: '',
  })
  console.log('ðŸš€ ~ streamingData:', streamingData)

  // State to keep track of whether getting the streaming URL failed
  const [isStreamGetUrlFailed, setIsStreamGetUrlFailed] = useState<boolean>(false)

  // State to keep track of whether the stream is generated and available
  const [isStreamIsGenerated, setIsStreamIsGenerated] = useState<boolean>(false)

  // State to keep track of the number of attempts to check if the stream is generated
  const [countOfCheckIsStreamIsGenerated, setCountOfCheckIsStreamIsGenerated] = useState<number>(0)

  // Ref to hold the interval for controlling streaming
  const streamControlIntervalRef = useRef<NodeJS.Timeout | null>(null)

  // Ref to hold the interval for retrying to get stream URL
  const retryStreamGetUrlIntervalRef = useRef<NodeJS.Timeout | null>(null)

  // Ref to hold the interval for checking if the stream is generated
  const checkStreamIsGeneratedIntervalRef = useRef<NodeJS.Timeout | null>(null)

  // API URL for fetching stream data based on the component's 'isLoading' & 'type' prop
  const streamReqUrl = !isLoading
    ? type === 'camera'
      ? cameraApi.getStream(deviceId || '0')
      : channelApi.getStream(deviceId || '0')
    : null

  // SWR Mutation hook to get the stream URL from the server
  const { trigger: getStreamUrl, isMutating: getStreamUrlIsLoading } = useSWRMutation(
    streamReqUrl,
    sendPostRequest,
    {
      onSuccess: (data: ISingleServerResponse<IStreamResult | string>) => {
        if (typeof data.data !== 'string') {
          const { StreamingId, StreamingUrl } = data.data
          setIsStreamGetUrlFailed(false)
          setStreamingData({ StreamingId, StreamingUrl })
        }
      },
      onError: (error) => {
        setIsStreamGetUrlFailed(true)
      },
    }
  )

  const handleGetStreamUrl = () => {
    getStreamUrl({ StreamingChannel: currentStreamingType })
  }

  // API URL for controlling streaming on the server
  const controlStreamingReqUrl =
    streamingData.StreamingId && deviceId ? channelApi.controlStreaming : null

  // SWR Mutation hook to trigger controlling streaming
  const { trigger: controlStreamingTrigger } = useSWRMutation(
    controlStreamingReqUrl,
    sendPostRequest,
    {
      onError: () => {
        handleGetStreamUrl()
      },
    }
  )

  // Function to call control streaming action with the given streamingId
  const callControlStreaming = (streamingId: string) => {
    controlStreamingTrigger({
      StreamingId: streamingId,
      Action: 'continue',
    })
  }

  // Function to check if the stream is generated by fetching the stream URL
  const checkStreamIsGenerated = () => {
    if (streamingData.StreamingUrl) {
      setIsStreamIsGenerated(false)
      setCountOfCheckIsStreamIsGenerated(0)
      clearInterval(checkStreamIsGeneratedIntervalRef.current as NodeJS.Timeout)
      fetch(STREAM_URL + streamingData.StreamingUrl)
        .then((r) => {
          if (r.status === 200) {
            setIsStreamIsGenerated(true)
            setCountOfCheckIsStreamIsGenerated(0)
          } else {
            throw new Error('Stream not found!')
          }
        })
        .catch((e) => {
          checkStreamIsGeneratedIntervalRef.current = setInterval(() => {
            fetch(STREAM_URL + streamingData.StreamingUrl)
              .then((r) => {
                if (r.status === 200) {
                  setIsStreamIsGenerated(true)
                  setCountOfCheckIsStreamIsGenerated(0)
                  clearInterval(checkStreamIsGeneratedIntervalRef.current as NodeJS.Timeout)
                } else {
                  throw new Error('Stream not found!')
                }
              })
              .catch(() => {
                setCountOfCheckIsStreamIsGenerated((prev) => prev + 1)
              })
          }, 1000)
        })
    }

    return () => {
      if (checkStreamIsGeneratedIntervalRef.current) {
        clearInterval(checkStreamIsGeneratedIntervalRef.current)
      }
    }
  }

  // Fetch the stream URL when the component mounts or the 'currentStreamingType' changes
  useEffect(() => {
    if (deviceId) {
      setIsStreamIsGenerated(false)
      setCountOfCheckIsStreamIsGenerated(0)
      handleGetStreamUrl()
    }
  }, [deviceId, currentStreamingType])

  // Retry fetching the stream URL every 5 seconds if it failed previously
  useEffect(() => {
    if (isStreamGetUrlFailed) {
      streamControlIntervalRef.current = setInterval(() => {
        getStreamUrl({ StreamingChannel: currentStreamingType })
      }, 5000)
    }

    return () => {
      if (streamControlIntervalRef.current) {
        clearInterval(streamControlIntervalRef.current)
      }
    }
  }, [isStreamGetUrlFailed])

  // Retry fetching the stream URL every 10 attempts if the stream is not generated
  useEffect(() => {
    if (countOfCheckIsStreamIsGenerated % 10 === 0 && countOfCheckIsStreamIsGenerated !== 0) {
      getStreamUrl({ StreamingChannel: currentStreamingType })
    }
  }, [countOfCheckIsStreamIsGenerated])

  // Effect to manage stream control and checking if the stream is generated
  useEffect(() => {
    if (streamingData.StreamingUrl && !isStreamGetUrlFailed) {
      checkStreamIsGenerated()
      callControlStreaming(streamingData.StreamingId)
      retryStreamGetUrlIntervalRef.current = setInterval(() => {
        callControlStreaming(streamingData.StreamingId)
      }, 10000)
    }

    return () => {
      if (retryStreamGetUrlIntervalRef.current) {
        clearInterval(retryStreamGetUrlIntervalRef.current)
        if (checkStreamIsGeneratedIntervalRef.current) {
          clearInterval(checkStreamIsGeneratedIntervalRef.current)
        }
      }
    }
  }, [streamingData])

  const headerActionButtons: IActionsButton[] = [
    {
      color: currentStreamingType === 'sub' ? 'cancel' : 'primary',
      text: t`Main`,
      onClick: () => setCurrentStreamingType('main'),
      size: 'small',
    },
    {
      color: currentStreamingType === 'main' ? 'cancel' : 'primary',
      text: t`Sub`,
      onClick: () => setCurrentStreamingType('sub'),
      size: 'small',
    },
  ]

  // if (isLoading) {
  //   return <div className="m-4 mb-0 border rounded-md h-max loading min-h-max aspect-[157/108]" />
  // }

  return (
    <div className="w-full px-4 pt-4 bg-white rounded-md">
      <FormContainer twoPart={false}>
        <FormCardWithHeader
          icon={channelIcon}
          header={name || ''}
          twoPart={false}
          headerActionButtons={headerActionButtons}
          padding={false}
        >
          <LiveBox
            streamUrl={streamingData.StreamingUrl}
            isLoading={
              isLoading || getStreamUrlIsLoading || isStreamGetUrlFailed || !isStreamIsGenerated
            }
          />
        </FormCardWithHeader>
      </FormContainer>
    </div>
  )
}

export default ViewBox
